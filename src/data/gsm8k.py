"""
GSM8K (Grade School Math 8K) dataset loader.

GSM8K contains 8.5K grade school math word problems requiring multi-step reasoning.
Each problem has a natural language solution and a final numerical answer.

Reference: Cobbe et al. 2021 - "Training Verifiers to Solve Math Word Problems"
"""

from typing import List, Optional, Dict, Any
import re
from datasets import load_dataset
from .base import BaseDataset, DatasetExample


class GSM8KDataset(BaseDataset):
    """
    GSM8K dataset loader for math word problems.
    
    Usage:
        dataset = GSM8KDataset(split="test")
        
        for example in dataset:
            # Get question
            question = example.question
            
            # Generate answer with your LLM
            model_answer = generate(question)
            
            # Extract numerical answer and check correctness
            # CHANGE: Corrected usage to call the dataset method, not DatasetExample.
            is_correct = dataset.is_correct(example, model_answer)
    """
    
    def __init__(
        self,
        split: str = "test",
        max_examples: Optional[int] = None
    ):
        """
        Initialize GSM8K dataset.
        
        Args:
            split: Dataset split ("train", "test")
            max_examples: Maximum number of examples to load (None = all)
        """
        self.max_examples = max_examples
        super().__init__(split)
    
    def _load_data(self) -> List[DatasetExample]:
        """Load GSM8K data from HuggingFace datasets."""
        # Load dataset
        dataset = load_dataset(
            "gsm8k",
            "main",
            split=self.split,
            trust_remote_code=True
        )
        
        # Limit examples if specified
        if self.max_examples is not None:
            dataset = dataset.select(range(min(self.max_examples, len(dataset))))
        
        examples = []
        for item in dataset:
            # Extract gold answer from solution
            # Solution format: "Step 1...\nStep 2...\n#### 42"
            gold_answer = self._extract_answer(item["answer"])
            
            example = DatasetExample(
                question=item["question"].strip(),
                choices=[str(gold_answer)],  # Store gold answer as single choice
                answer=0,  # Dummy value
                metadata={
                    "gold_answer": gold_answer,
                    "solution": item["answer"],  # Full solution with steps
                }
            )
            examples.append(example)
        
        return examples
    
    @staticmethod
    def _extract_answer(solution: str) -> float:
        """
        Extract numerical answer from solution string.
        
        GSM8K solutions end with "#### ANSWER" format.
        
        Args:
            solution: Full solution string
            
        Returns:
            Numerical answer as float
        """
        # Look for "#### NUMBER" pattern at the end
        match = re.search(r'####\s*(-?[\d,]+(?:\.\d+)?)', solution)
        if match:
            answer_str = match.group(1).replace(',', '')  # Remove commas
            try:
                return float(answer_str)
            except ValueError:
                pass
        
        # Fallback: try to find any number at the end
        numbers = re.findall(r'-?[\d,]+(?:\.\d+)?', solution)
        if numbers:
            try:
                return float(numbers[-1].replace(',', ''))
            except ValueError:
                pass
        
        raise ValueError(f"Could not extract answer from solution: {solution}")
    
    def is_correct(
        self,
        example: DatasetExample,
        model_answer: str,
        tolerance: float = 1e-4
    ) -> bool:
        """
        Check if model answer matches gold answer.
        
        Args:
            example: The dataset example
            model_answer: Answer string generated by model
            tolerance: Numerical tolerance for floating point comparison
            
        Returns:
            True if answer is correct, False otherwise
        """
        gold = example.metadata["gold_answer"]
        
        # Extract number from model answer
        try:
            model_num = self._extract_number_from_text(model_answer)
        except ValueError:
            return False
        
        # Compare with tolerance
        return abs(model_num - gold) < tolerance
    
    @staticmethod
    def _extract_number_from_text(text: str) -> float:
        """
        Extract numerical answer from model-generated text.
        
        Tries multiple strategies:
        1. Look for "#### NUMBER" format (if model mimics training format)
        2. Look for explicit answer statements ("The answer is X")
        3. Take the last number in the text
        
        Args:
            text: Model-generated answer text
            
        Returns:
            Extracted number as float
            
        Raises:
            ValueError: If no number can be extracted
        """
        # Strategy 1: Check for "#### NUMBER" format
        match = re.search(r'####\s*(-?[\d,]+(?:\.\d+)?)', text)
        if match:
            return float(match.group(1).replace(',', ''))
        
        # Strategy 2: Look for explicit answer statements
        patterns = [
            r'(?:the answer is|answer:|final answer:?)\s*(-?[\d,]+(?:\.\d+)?)',
            r'(?:therefore|thus|so),?\s*(?:the answer is)?\s*(-?[\d,]+(?:\.\d+)?)',
            r'=\s*(-?[\d,]+(?:\.\d+)?)\s*(?:\.|$)',  # Ends with = NUMBER
        ]
        
        for pattern in patterns:
            match = re.search(pattern, text, re.IGNORECASE)
            if match:
                return float(match.group(1).replace(',', ''))
        
        # Strategy 3: Take the last number
        numbers = re.findall(r'-?[\d,]+(?:\.\d+)?', text)
        if numbers:
            return float(numbers[-1].replace(',', ''))
        
        raise ValueError(f"No number found in text: {text}")
    
    def get_statistics(self) -> Dict[str, Any]:
        """Get GSM8K-specific statistics."""
        base_stats = super().get_statistics()
        
        # Answer statistics
        answers = [ex.metadata["gold_answer"] for ex in self.data]
        
        return {
            **base_stats,
            "avg_answer": sum(answers) / len(answers) if answers else 0,
            "max_answer": max(answers) if answers else 0,
            "min_answer": min(answers) if answers else 0,
            "negative_answers": sum(1 for a in answers if a < 0),
            "decimal_answers": sum(1 for a in answers if a != int(a))
        }


# Helper function for generating confidence labels
def generate_gsm8k_labels(
    dataset: GSM8KDataset,
    model_answers: List[str],
    tolerance: float = 1e-4
) -> List[int]:
    """
    Generate correctness labels for GSM8K given model answers.
    
    Args:
        dataset: GSM8K dataset
        model_answers: List of model-generated answers (same length as dataset)
        tolerance: Numerical tolerance for floating point comparison
        
    Returns:
        List of labels (1 = correct, 0 = incorrect)
    """
    if len(model_answers) != len(dataset):
        raise ValueError(
            f"Number of answers ({len(model_answers)}) must match "
            f"dataset size ({len(dataset)})"
        )
    
    labels = []
    for example, answer in zip(dataset, model_answers):
        try:
            is_correct = dataset.is_correct(example, answer, tolerance)
            labels.append(1 if is_correct else 0)
        except Exception:
            # If we can't extract an answer, mark as incorrect
            labels.append(0)
    
    return labels
